<ul class="carousel-track" style="width: 17280px; transform: translateX(0px);">


    <li class="carousel-slide carousel-slide-active" data-ssplayer-slide-index="0" style="width: 508px; height: 718px;">
        <img class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/1/1726554782042?e=1730332800&amp;v=beta&amp;t=CZeAf98-IjIvpP4dKhzXGJE2L9Nn8G3JrY5YmPr7mGQ"
            alt="1 | P a g e"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/1/1726554782042?e=1730332800&amp;v=beta&amp;t=CZeAf98-IjIvpP4dKhzXGJE2L9Nn8G3JrY5YmPr7mGQ">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="1" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/2/1726554782042?e=1730332800&amp;v=beta&amp;t=rwvENF80ImykIjx8-T9ENkHVmUgIh6-Ey-Jt_L9UKkc"
            alt="2 | P a g e Searching Algorithms Linear Search: Linear search is a simple searching algorithm that sequentially checks each element in a list or array until it finds the target value or reaches the end of the list. It is also known as a sequential search. Time Complexity: O(n)"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/2/1726554782042?e=1730332800&amp;v=beta&amp;t=rwvENF80ImykIjx8-T9ENkHVmUgIh6-Ey-Jt_L9UKkc">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="2" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/3/1726554782042?e=1730332800&amp;v=beta&amp;t=tdAMoxnNPthc96nYJE4Bw4B0WFAlY1LUKcTjXF51Oco"
            alt="3 | P a g e Sample Problems: • Kth Missing Positive Number Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Return the kth positive integer that is missing from this array. Input: arr = [2,3,4,7,11], k = 5 Output: 9 • Searching a number Given an array Arr of N elements and a integer K. Your task is to return the position of first occurence of K in the given array. Input: N = 5, K = 16 Arr [ ] = {9, 7, 2, 16, 4} Output: 4"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/3/1726554782042?e=1730332800&amp;v=beta&amp;t=tdAMoxnNPthc96nYJE4Bw4B0WFAlY1LUKcTjXF51Oco">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="3" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/4/1726554782042?e=1730332800&amp;v=beta&amp;t=m2Bsg7n_lBU8bzuXaujS9zRmyHm7IAa0nHbVAPnXOxg"
            alt="4 | P a g e Binary Search: Binary search is an efficient searching algorithm that works on sorted lists or arrays. It follows a divide-and-conquer approach, repeatedly dividing the search space in half until the target element is found or determined to be absent. Time Complexity: O(log2 n)"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/4/1726554782042?e=1730332800&amp;v=beta&amp;t=m2Bsg7n_lBU8bzuXaujS9zRmyHm7IAa0nHbVAPnXOxg">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="4" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/5/1726554782042?e=1730332800&amp;v=beta&amp;t=Vkhix_Je3xAOECZewmvy00s8SGqh8QMGrc3VQhRwy7M"
            alt="5 | P a g e Sample Problems: • Binary Search Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity. Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 • Cake Distribution Problem Geek is organizing a birthday party, so his friends brought a cake for him. The cake consists of N chunks, whose individual sweetness is represented by the sweetness array. Now at the time of distribution, Geek cuts the cake into K + 1 pieces to distribute among his K friends. One piece he took for himself. Each piece consists of some consecutive chunks. He is very kind, so he left the piece with minimum sweetness for him. You need to find the maximum sweetness that the Geek can get if he distributes the cake optimally. Input: N = 6, K = 2 sweetness[ ] = {6, 3, 2, 8, 7, 5} Output: 9"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/5/1726554782042?e=1730332800&amp;v=beta&amp;t=Vkhix_Je3xAOECZewmvy00s8SGqh8QMGrc3VQhRwy7M">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="5" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/6/1726554782042?e=1730332800&amp;v=beta&amp;t=wF1JJOWBJKGNuqWrgtRX6UFZVfa_25H0ecHQAdgD8EE"
            alt="6 | P a g e Sorting Algorithms Bubble Sort Algorithms: Bubble sort is a simple sorting algorithm that repeatedly steps through the list or array, compares adjacent elements, and swaps them if they are in the wrong order. The algorithm gets its name from the way smaller elements &quot;bubble&quot; to the top of the list with each iteration. Time Complexity: O(n2)"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/6/1726554782042?e=1730332800&amp;v=beta&amp;t=wF1JJOWBJKGNuqWrgtRX6UFZVfa_25H0ecHQAdgD8EE">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="6" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/7/1726554782042?e=1730332800&amp;v=beta&amp;t=yCQ1CV3O2bzRzuvT5CfLhxZ9Ke9B2PQJ7HBqkHFOHd8"
            alt="7 | P a g e Sample Problems: • Sort Colors Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library's sort function. Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] • Bubble Sort Given an Integer N and a list arr. Sort the array using bubble sort algorithm. Input: N = 5 arr[ ] = {4, 1, 3, 9, 7} Output: 1 3 4 7 9"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/7/1726554782042?e=1730332800&amp;v=beta&amp;t=yCQ1CV3O2bzRzuvT5CfLhxZ9Ke9B2PQJ7HBqkHFOHd8">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="7" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/8/1726554782042?e=1730332800&amp;v=beta&amp;t=g0mkrkqX7zEN-ljBLjknjp98ff2qi5rrZerSs74xn5Q"
            alt="8 | P a g e Insertion Sort Algorithms: Insertion sort is a simple sorting algorithm that builds the final sorted array one element at a time. It iterates through the input list or array and gradually expands a sorted portion of the list by inserting each new element in its proper place. Time Complexity: O(n2)"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/8/1726554782042?e=1730332800&amp;v=beta&amp;t=g0mkrkqX7zEN-ljBLjknjp98ff2qi5rrZerSs74xn5Q">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="8" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/9/1726554782042?e=1730332800&amp;v=beta&amp;t=6PPJN1JrPVhhyri6OzWmi9g2iTHwWmcLGoJ5tAzUuqA"
            alt="9 | P a g e Sample Problems: • Insertion Sort The task is to complete the insert() function which is used to implement Insertion Sort. Input: N = 5, arr[ ] = { 4, 1, 3, 9, 7} Output: 1 3 4 7 9 • Insertion Sort || The first line contains one space separated integer N denoting the number of elements. The Second line contains N space separated integers denoting the elements of the array. You need to complete insertionSort function which contains a array of size n and print the final sorted array in this function only. Input: 7 6 8 5 4 9 Output: 4 5 6 7 8 9"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/9/1726554782042?e=1730332800&amp;v=beta&amp;t=6PPJN1JrPVhhyri6OzWmi9g2iTHwWmcLGoJ5tAzUuqA">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="9" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/10/1726554782042?e=1730332800&amp;v=beta&amp;t=KTYhSbrg6IXq3QtiO6B-rXUIP6ksfOPklojY-DGVrAs"
            alt="10 | P a g e Selection Sort Algorithms: Selection sort is a simple sorting algorithm that divides the input list into two parts: the sorted portion at the beginning and the unsorted portion at the end. It repeatedly selects the smallest element from the unsorted portion and swaps it with the element at the beginning of the unsorted portion, thus expanding the sorted portion by one element. Time Complexity: O(n2)"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/10/1726554782042?e=1730332800&amp;v=beta&amp;t=KTYhSbrg6IXq3QtiO6B-rXUIP6ksfOPklojY-DGVrAs">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="10" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/11/1726554782042?e=1730332800&amp;v=beta&amp;t=JL2onFSvnfcpMV56mSq8Umw8IEAux7_7y-FJu6wv6FQ"
            alt="11 | P a g e Sample Problems: • Selection Sort Given an unsorted array of size N, use selection sort to sort arr[ ] in increasing order. Example 1: Input: N = 5, arr[ ] = {4, 1, 3, 9, 7} Output: 1 3 4 7 9 • Selection Sort || Implement Selection Sort on a given array, and make it sorted. Input Format First line of the input contains an integer, N, which denotes the length of the array. Next N inputs are elements of the array that is to be sorted in ascending order. Output Format Sorted output where each element is space separated Example 1: Input: 1 2 7 3 4 Output: 1 2 3 4 7"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/11/1726554782042?e=1730332800&amp;v=beta&amp;t=JL2onFSvnfcpMV56mSq8Umw8IEAux7_7y-FJu6wv6FQ">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="11" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/12/1726554782042?e=1730332800&amp;v=beta&amp;t=RudYDWhKvwbPYqaRpWDka786rB-T0U5zsF-5Ki7SYpk"
            alt="12 | P a g e Heap Sort Algorithms: Heap sort is a comparison-based sorting algorithm that uses a binary heap data structure to sort elements. It involves building a heap from the input list and repeatedly extracting the maximum (for ascending order) or minimum (for descending order) element from the heap and placing it at the end of the sorted portion of the list. Time Complexity: O(n*log n)"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/12/1726554782042?e=1730332800&amp;v=beta&amp;t=RudYDWhKvwbPYqaRpWDka786rB-T0U5zsF-5Ki7SYpk">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="12" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/13/1726554782042?e=1730332800&amp;v=beta&amp;t=JiL9Dy0wPdKd330-TC5rqUF5YhxbnGee8-v4W2h0gWw"
            alt="13 | P a g e Sample Problems: • Heap Sort Given an array of size N. The task is to sort the array elements by completing functions heapify() and buildHeap() which are used to implement Heap Sort. Input: N = 5, arr [ ] = {4,1,3,9,7} Output: 1 3 4 7 9 • Heap Sort || Given an array of size N. The task is to sort the array elements by implementing Heap Sort. • Hint: Make two functions heapify() and heapSort(). • The passed array needs to be sorted Input Format The first line contains an integer N, the size of the array. The second line contains N spaced integers, the elements of the array. Output Format Print the sorted array. Input: 4 1 3 9 7 Output: 1 3 4 7 9"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/13/1726554782042?e=1730332800&amp;v=beta&amp;t=JiL9Dy0wPdKd330-TC5rqUF5YhxbnGee8-v4W2h0gWw">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="13" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/14/1726554782042?e=1730332800&amp;v=beta&amp;t=k6Gjz4o-Uz8kE4pqv-iKmG28yKrCrso_cxa8WE_0Bas"
            alt="14 | P a g e Merge Sort Algorithms: Merge sort is a recursive sorting algorithm that follows the divide-and-conquer principle. It divides the input list or array into smaller subproblems, sorts them independently, and then merges them to obtain a sorted result. Time Complexity: O(n*log n)"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/14/1726554782042?e=1730332800&amp;v=beta&amp;t=k6Gjz4o-Uz8kE4pqv-iKmG28yKrCrso_cxa8WE_0Bas">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="14" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/15/1726554782042?e=1730332800&amp;v=beta&amp;t=KdNCT8TeyhO9Gge_105vD8G76Ael5EDzPWFNUhegBlY"
            alt="15 | P a g e Sample Problems: • Merge Sort Given an array arr[ ], its starting position l and its ending position r. Sort the array using merge sort algorithm. Input: N = 5, arr[ ] = {4 1 3 9 7} Output: 1 3 4 7 9"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/15/1726554782042?e=1730332800&amp;v=beta&amp;t=KdNCT8TeyhO9Gge_105vD8G76Ael5EDzPWFNUhegBlY">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="15" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/16/1726554782042?e=1730332800&amp;v=beta&amp;t=3bSbat-01zs_6ONgKMamUeuixL6FHgFCsKESbm3SwM8"
            alt="16 | P a g e Quick Sort Algorithms: Quick sort is a highly efficient, comparison-based sorting algorithm that follows the divide-and-conquer principle. It works by partitioning the input list or array into two subarrays based on a chosen pivot element, and recursively sorting the subarrays. Time Complexity: O(n*log n) Sample Problems: • Quick Sort Quick Sort is a Divide and Conquer algorithm. It picks an element as a pivot and partitions the given array around the picked pivot. Given an array arr[], its starting position is low (the index of the array) and its ending position is high(the index of the array). Input: N = 5, arr[ ] = { 4, 1, 3, 9, 7} Output:1 3 4 7 9"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/16/1726554782042?e=1730332800&amp;v=beta&amp;t=3bSbat-01zs_6ONgKMamUeuixL6FHgFCsKESbm3SwM8">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="16" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/17/1726554782042?e=1730332800&amp;v=beta&amp;t=By60oCyam8DrqbRyAxUtKFj7IM5tTw4PGmp7n-kGyJE"
            alt="17 | P a g e"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/17/1726554782042?e=1730332800&amp;v=beta&amp;t=By60oCyam8DrqbRyAxUtKFj7IM5tTw4PGmp7n-kGyJE">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="17" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/18/1726554782042?e=1730332800&amp;v=beta&amp;t=FvEAkAIa7KNEb-FTIKArb71bMnV1-5FrLklLZnv4KBI"
            alt="18 | P a g e Graph Algorithms Breadth-first search: Breadth-first search is an algorithm for searching a tree data structure for a node that satisfies a given property. It starts at the tree root and explores all nodes at the present depth prior to moving on to the nodes at the next depth level Time Complexity: O(V + E)"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/18/1726554782042?e=1730332800&amp;v=beta&amp;t=FvEAkAIa7KNEb-FTIKArb71bMnV1-5FrLklLZnv4KBI">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="18" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/19/1726554782042?e=1730332800&amp;v=beta&amp;t=qX7MDRymCqlm9OI6xXblnLpnHL3870s4fKJFSp8l9uI"
            alt="19 | P a g e Sample Problems: • Symmetric Tree Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). Example 1: Input: root = [1,2,2,3,4,4,3] Output: true • Shortest Prime Path You are given two four digit prime numbers Num1 and Num2. Find the distance of the shortest path from Num1 to Num2 that can be attained by altering only one single digit at a time. Every number obtained after changing a digit should be a four digit prime number with no leading zeros. Input: Num1 = 1033 Num2 = 8179 Output: 6"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/19/1726554782042?e=1730332800&amp;v=beta&amp;t=qX7MDRymCqlm9OI6xXblnLpnHL3870s4fKJFSp8l9uI">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="19" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/20/1726554782042?e=1730332800&amp;v=beta&amp;t=VkctAYmGHF_2es0HBZWyn4t2TwMzEwpn4Ex-nRBrzOE"
            alt="20 | P a g e Depth-first search: Depth-first search is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node and explores as far as possible along each branch before backtracking. Time Complexity: O(V + E)"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/20/1726554782042?e=1730332800&amp;v=beta&amp;t=VkctAYmGHF_2es0HBZWyn4t2TwMzEwpn4Ex-nRBrzOE">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="20" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/21/1726554782042?e=1730332800&amp;v=beta&amp;t=RF6cPdXLaF55ETcScs3Aw5AqSakizxIZ_GYulq9VeSk"
            alt="21 | P a g e Sample Problems: • Binary Tree Inorder Traversal Given the root of a binary tree, return the inorder traversal of its nodes' values. Input: root = [1,null,2,3] Output: [1,3,2] • X Total Shapes Given a grid of n*m consisting of O's and X's. The task is to find the number of 'X' total shapes. Note: 'X' shape consists of one or more adjacent X's (diagonals not included). Input: grid = {{X,O,X},{O,X,O},{X,X,X}} Output: 3 • Select Nodes Given N nodes of a tree and a list of edges. Find the minimum number of nodes to be selected to light up all the edges of the tree. An edge lights up when at least one node at the end of the edge is selected. Input: N = 6 Edges [ ] = {(1,2), (1,3), (2,4), (3,5), (3,6)} Output: 2"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/21/1726554782042?e=1730332800&amp;v=beta&amp;t=RF6cPdXLaF55ETcScs3Aw5AqSakizxIZ_GYulq9VeSk">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="21" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/22/1726554782042?e=1730332800&amp;v=beta&amp;t=ukYDmTD8s04XLp7KjmB_WwnZaApgEhA_cTLpZF8PDWg"
            alt="22 | P a g e Dijkstra's algorithm Dijkstra's algorithm is an algorithm for finding the shortest paths between nodes in a weighted graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later. The algorithm exists in many variants Time Complexity: O ( V + E log V ) ."
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/22/1726554782042?e=1730332800&amp;v=beta&amp;t=ukYDmTD8s04XLp7KjmB_WwnZaApgEhA_cTLpZF8PDWg">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="22" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/23/1726554782042?e=1730332800&amp;v=beta&amp;t=lxnfthXo8WYJKTZgA_WM0KHmthofZMVcIMzumraxb8k"
            alt="23 | P a g e Sample Problems: • Implementing Dijkstra Algorithm Given a weighted, undirected and connected graph of V vertices and an adjacency list adj where adj[i] is a list of lists containing two integers where the first integer of each list j denotes there is edge between i and j , second integers corresponds to the weight of that edge . You are given the source vertex S and You to Find the shortest distance of all the vertex's from the source vertex S. You have to return a list of integers denoting shortest distance between each node and Source vertex S. Input: V = 2 adj [ ] = {{{1, 9}}, {{0, 9}}}, S = 0 Output: 0 9 • Path with Maximum Probability You are given an undirected weighted graph of n nodes (0- indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i]. Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability. Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2 Output: 0.25000"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/23/1726554782042?e=1730332800&amp;v=beta&amp;t=lxnfthXo8WYJKTZgA_WM0KHmthofZMVcIMzumraxb8k">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="23" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/24/1726554782042?e=1730332800&amp;v=beta&amp;t=B1AP2sR_ZEPLq29VTZi2x-CGMSnKJgRJHWRrS3iKxn0"
            alt="24 | P a g e Kadane’s Algorithm Kadane’s Algorithm: Kadane's algorithm is an efficient algorithm used to find the maximum sum of a contiguous subarray within a given array of numbers. It is often used to solve the maximum subarray problem. Time Complexity: O(n)"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/24/1726554782042?e=1730332800&amp;v=beta&amp;t=B1AP2sR_ZEPLq29VTZi2x-CGMSnKJgRJHWRrS3iKxn0">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="24" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/25/1726554782042?e=1730332800&amp;v=beta&amp;t=1R9bDOdOBbwbvjzce4NGZvQ55hnoM_EJ_dGUkj5iS98"
            alt="25 | P a g e Sample Problems: • Maximum Subarray Given an integer array nums, find the subarray with the largest sum, and return its sum. Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 • Save Your Life Given a string w, integer array b, character array x and an integer n. n is the size of array b and array x. Find a substring which has the sum of the ASCII values of its every character, as maximum. ASCII values of some characters are redefined. Input: W = abcde N = 1 X[ ] = { 'c' } B[ ] = { -1000 } Output: de • Max Sum Find max sum contiguous subarray. Input: [-3, -4, 5, -1, 2, -4, 6, -1] Output: 8"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/25/1726554782042?e=1730332800&amp;v=beta&amp;t=1R9bDOdOBbwbvjzce4NGZvQ55hnoM_EJ_dGUkj5iS98">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="25" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/26/1726554782042?e=1730332800&amp;v=beta&amp;t=9gCVfdLy7bmPI_AuGtpFdBa8EhqtnWsmbGibDRvyqFI"
            alt="26 | P a g e Tree Algorithm Inorder Traversal: • In an inorder traversal, the left subtree is visited first, followed by the root node, and then the right subtree. • The inorder traversal visits the nodes of a binary tree in ascending order when applied to a binary search tree (BST). • The pseudocode for inorder traversal is as follows: Time Complexity: O(n)"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/26/1726554782042?e=1730332800&amp;v=beta&amp;t=9gCVfdLy7bmPI_AuGtpFdBa8EhqtnWsmbGibDRvyqFI">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="26" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/27/1726554782042?e=1730332800&amp;v=beta&amp;t=AyOXdx8tTqIpfyC1dSOEFHpl-F4Qh-BhTn7TtQSxlVE"
            alt="27 | P a g e Sample Problems: • Inorder Traversal Given a Binary Tree, find the In-Order Traversal of it. Input: Output: 3 1 2 • Inorder Traversal || Given the root of a binary tree, return the inorder traversal of its nodes' values. Input: Input: root = [1,null,2,3] Output: [1,3,2]"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/27/1726554782042?e=1730332800&amp;v=beta&amp;t=AyOXdx8tTqIpfyC1dSOEFHpl-F4Qh-BhTn7TtQSxlVE">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="27" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/28/1726554782042?e=1730332800&amp;v=beta&amp;t=a34dESNiJAK3U3ZwYplsQdfQIGcOypH5vzq4de10cT4"
            alt="28 | P a g e Preorder Traversal: • In a preorder traversal, the root node is visited first, followed by the left subtree, and then the right subtree. • The preorder traversal is useful for creating a copy of a tree, as the nodes are visited in the order they appear in the original tree. • The pseudocode for preorder traversal is as follows: Time Complexity: O(n)"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/28/1726554782042?e=1730332800&amp;v=beta&amp;t=a34dESNiJAK3U3ZwYplsQdfQIGcOypH5vzq4de10cT4">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="28" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img
            class="carousel-lazy-element carousel-slide-is-portrait carousel-element-loaded carousel-element-load-success"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/29/1726554782042?e=1730332800&amp;v=beta&amp;t=1SBbL_tHwx9l69GD4Ryxh3kc2TiJLFFwQDIt30Pm-HY"
            alt="29 | P a g e Sample Problems: • Preorder Traversal Given a binary tree, find its preorder traversal. Input: Output: 1 4 4 2 • Preorder Traversal || Given the root of a binary tree, return the preorder traversal of its nodes' values. Input: root = [1,null,2,3] Output: [1,2,3]"
            src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/29/1726554782042?e=1730332800&amp;v=beta&amp;t=1SBbL_tHwx9l69GD4Ryxh3kc2TiJLFFwQDIt30Pm-HY">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="29" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img class="carousel-lazy-element carousel-slide-is-portrait"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/30/1726554782042?e=1730332800&amp;v=beta&amp;t=Jr7FXp-t1bBbpMXVLHrna6T-vXfthmna-ZFOclAa5Kc"
            alt="30 | P a g e Postorder Traversal: • In a postorder traversal, the left subtree is visited first, followed by the right subtree, and finally the root node. • The postorder traversal is commonly used to delete nodes from a tree since it ensures that a node's children are deleted before the node itself. • The pseudocode for postorder traversal is as follows: Time Complexity: O(n)">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="30" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img class="carousel-lazy-element carousel-slide-is-portrait"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/31/1726554782042?e=1730332800&amp;v=beta&amp;t=lmAzD5O9fInRkTScB542r9fU4Y9uebSvJJ472xCmbcw"
            alt="31 | P a g e Sample Problems: • Postorder Traversal Given a binary tree, find the Postorder Traversal of it. Input: Output: 11 13 10 8 19 • Postorder Traversal || Given the root of a binary tree, return the postorder traversal of its nodes' values. Input: root = [1,null,2,3] Output: [3,2,1]">
    </li>
    <li class="carousel-slide" data-ssplayer-slide-index="31" style="width: 508px; height: 718px;" tabindex="-1"
        aria-hidden="true"><img class="carousel-lazy-element carousel-slide-is-portrait"
            data-src="https://media.licdn.com/dms/image/D4D1FAQHNlNMuHdy35A/feedshare-document-images_800/32/1726554782042?e=1730332800&amp;v=beta&amp;t=waJOgenNPPgtfamtNdiKOv1CdewkvaixygvPgTa4H3g"
            alt="32"></li>
</ul>